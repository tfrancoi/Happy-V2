Ensemble de type liste:
{Call, If, While, Assignement, Programme, Block_fun, Fun, Block_arg, Skip,  }
Terminaux : {fun, int, float, string, if, set, while, skip, of, Expr, Id}


1) Détermine le type le plus spécifique d'un noeud en regardant le type le plus spécifique du premier fils
fun 	=> Fun
skip	=> Skip
of		=> Block_arg
if  	=> If
set		=> Assignement
while => While
Id		=> Call

spécifique => spécifique

n 0 ou plus  
N 1 ou plus
2) Connaissant le type (spécifique ou non) du parent, on trouve l'ensemble des types généraux possibles pour les enfant
Programme 	? N * {Block_fun, Fun}	
Block_fun 	? N * {Block_fun, Fun} 
Fun					? 1 * {fun} +  1 * {Id_unb} + 1 * {Block_arg} + 1 * {Instr}
Skip 				? 1 * {skip}
Block_arg		? 1 * of + 1 * {Id_unb} + n * {Id_unb}
Instr				? 1 * {Id_fun, if, while, set, Instr, skip} + n * {Expr, Instr} 
Expr				?	1 * {Id, set} + 1 * {Id_unb, Expr} + n * {Expr}   //seulement quand on a un call
Assignement	? 1 * {set} + 1 * {Id_unb} + 1 * {Expr}
Call				? 1 * {Id_fun} + N * {Expr}
If 					? 1 * {if} + 1 * {Expr} + 2 * {Instr}
While				? 1 * {while} + 1 * {Expr} + 1 *{Instr}



3) Les réécritures : Réécrit les types les plus spécifique en type générale
Call 				--> {Instr, Expr}
Assignement	--> {Instr, Expr}
If					--> {Instr}
While				--> {Instr}
Skip				--> {Instr}
Id					--> {Id_unb, Id_fun, Id}
String 			--> {Expr}
Float 			--> {Expr}
Int					--> {Expr}



4) constraintes des voisins
1) les contraintes sur les voisins, si le premier est ca alors le voisin est
Instr ? n * Instr




<Programme> 			--> <Fun_list> | <Block_fun>

<Block_fun> 			--> '(' <Block_fun> ')' | <Block_fun> <Block_fun> | '(' <Fun_list> ')' 
<Fun_list>  			--> <Fun> | <Fun> <Fun_list>

<Fun> 						--> '(' 'fun' <Id_unb> <Block_arg> <Instr> ')' | <Class>
<Block_arg>				--> '(' 'of' <Id_list> ')'
<Id_list> 				--> <Id_unb> | <Id_unb> <Id_list>
<Id_unb>					-->	<Id>

<Instr>						--> <Block> | <If> | <While> | <Call> | <Assignement> | <Skip>
<Block>						--> '(' <Instr_list> ')'
<Instr_list>			--> <Instr> | <Instr> <Instr_list>
<Assignement> 		--> '(' 'set' <Id_unb> <Expr> ')'
<If> 							--> '(' 'if' <Expr> <Instr> <Instr> ')'
<While> 					--> '(' 'while' <Expr> <Instr> ')'
<Skip>						--> '(' 'skip' ')'

<Expr>						--> <Call> | <Id> | <Value> | <Assignement>
<Call>  					--> '(' <Id_fun> <Expr_list> ')'
<Expr_list>				--> <Expr> | <Expr> <Expr_list>
<value> 					--> <string> | <Number>
<Number>					--> <int> | <float>


si l'intersection des type possible et des contraintes est vide ==> erreur de syntaxe
si l'intersection des type possible et des contraintes > 1 ==> ambuiguité, erreur de la grammaire, manque de contrainte ou syntaxe



